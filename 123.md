# Git: руководство для начинающих.

# Содержание:
## Инструкция для работы с GIT и удаленными репозиториями.
# 1 часть:
1. Что такое Git?
2. Подготовка репозитория.
3. Определение состояния.
4. Подготовка файлов.
###  Фиксация изменений.
* Как сделать коммит.
###  Как посмотреть коммиты.

# Дополнительно:
1. Отслеживание изменений, сделанных в коммитах.
2. Возвращение файла к предыдущему состоянию.
3. Исправление коммита.
* ### Заключение 1.

# 2 часть:
## Ветвление:
1. Создание новой ветки.
2. Переключение между ветками.
3. Слияние веток.

### Как удалять ветки в Git?
### Как удалить локальный репозиторий.

# 3 часть:
## Удаленные репозитории.
1. Что такое удаленный репозиторий.
2. Подключение к удаленному репозиторию.
3. Отправка изменений на сервер.
4. Запрос изменений с сервера.

* ### Заключение2.

# Инструкция для работы с GIT и удаленными репозиториями
# 1 часть

## Что такое Git?

Git - это одна из реализаций распределённых систем контроля версий, имеющая как и локальные, так и удалённые репозитории. Является самой популярной реализацией систем контроля версий в мире.

## Подготовка репозитория

Для создание репозитория необходимо выполнить команду **git init** в папке с репозиторием и у Вас создаться репозиторий (появится скрытая папка .git)

## Определение состояния 

**status** — это еще одна важнейшая команда, которая показывает информацию о текущем состоянии репозитория: актуальна ли информация на нём, нет ли чего-то нового, что поменялось, и так далее. Запускается командой **git status** 

## Подготовка файлов

В git есть концепция области подготовленных файлов. Можно представить ее как холст, на который наносят изменения, которые нужны в коммите. Сперва он пустой, но затем мы добавляем на него файлы (или части файлов, или даже одиночные строчки) командой **git add ./name fail** (в случае если у нас только один файл) и, наконец, коммитим все нужное в репозиторий (создаем слепок нужного нам состояния) командой **git commit -m "comment"** .

Если нам нужно добавить все, что находится в директории, мы можем использовать **git add -A**

После этого файл готов к коммиту. Сообщение о состоянии также говорит нам о том, какие изменения относительно файла были проведены в области подготовки — в данном случае это новый файл, но файлы могут быть модифицированы или удалены.

#  Фиксация изменений

## Как сделать коммит

Представим, что нам нужно добавить пару новых блоков в *html-разметку (index.html)* и стилизовать их в файле *style.css*. Для сохранения изменений, их необходимо *закоммитить*. Но сначала, мы должны обозначить эти файлы для Гита, при помощи команды **git add**, добавляющей (или подготавливающей) их к коммиту. Добавлять их можно по отдельности:

* git add index.html
* git add css/style.css

или вместе - всё сразу:

* git add 

Конечно добавлять всё сразу удобнее, чем прописывать каждую позицию отдельно. Однако, тут надо быть внимательным, чтобы не добавить по ошибке ненужные элементы. Если же такое произошло изъять оттуда ошибочный файл можно при помощи команды
**git reset:**
* git reset css/style.css

Теперь создадим непосредственно сам коммит

* git commit -m 'Add some code'

Флажок **-m** задаст **commit message** - комментарий разработчика. Он необходим для описания закоммиченных изменений. И здесь работает золотое правило всех комментариев в коде: «Максимально ясно, просто и содержательно обозначь написанное!»

## Как посмотреть коммиты

Для просмотра все выполненных фиксаций можно воспользоваться историей коммитов. Она содержит сведения о каждом проведенном коммите проекта. Запросить ее можно при помощи команды:

* git log

В ней содержиться вся информация о каждом отдельном коммите, с указанием его хэша, автора, списка изменений и даты, когда они были сделаны. Отследить интересующие вас операции в списке изменений, можно по хэшу коммита, при помощи команды **git show :**

* git show hash_commit

Ну а если вдруг нам нужно переделать **commit message** и внести туда новый комментарий, можно написать следующую конструкцию:

* git commit --amend -m "Новый комментарий"

В данном случае сообщение последнего коммита перезапишется. Но злоупотреблять этим не стоит, поскольку эта операция опасная и лучше ее делать до отправки коммита на сервер.


## Как удалить локальный репозиторий

Вам не понравился один из ваших локальных Git-репозиториев и вы хотите стереть его со своей машины. Для этого вам всего лишь надо удалить скрытую папку **«.git»** в корневом каталоге репозитория. Сделать это можно 3 способами:

1. Проще всего вручную удалить эту папку **«.git»** в корневом каталоге **«Git Local Warehouse».**
2. Также удалить, не устраивающий вас, репозиторий можно на **github.** Открываете нужный вам объект и переходите в пункт меню Настройки. Там, прокрутив ползунок вниз, вы попадете в зону опасности, где один из пунктов будет называться **«удаление этого хранилища».**
3. Последний метод удаления локального хранилища через командную строку, для этого в терминале необходимо ввести следующую команду:
* cd repository-path/
* rm -r .git

# Дополнительно

## 1. Отслеживание изменений, сделанных в коммитах

У каждого коммита есть свой уникальный идентификатор в виде строки цифр и букв. Чтобы просмотреть список всех коммитов и их идентификаторов, можно использовать команду **log:**

* git log

 Идентификаторы довольно длинные, но для работы с ними не обязательно копировать их целиком — первых 4-х символов будет вполне достаточно. Чтобы посмотреть, что нового появилось в коммите, мы можем воспользоваться командой  **show [commit]**

 * git show 1234

 Чтобы увидеть разницу между двумя коммитами, используется команда **diff** (с указанием промежутка между коммитами):

 * git diff 4321

 Мы сравнили первый коммит с последним, чтобы увидеть все изменения, которые были когда-либо сделаны. Обычно проще использовать **git difftool**, так как эта команда запускает графический клиент, в котором наглядно сопоставляет все изменения.

## 2. Возвращение файла к предыдущему состоянию

Гит позволяет вернуть выбранный файл к состоянию на момент определенного коммита. Это делается уже знакомой нам командой **checkout.** Она может быть использована для переключения между коммитами (это довольно распространенная ситуация для Гита - использование одной команды для различных, на первый взгляд, слабо связанных задач).
В следующем примере мы возьмем файл **hello.md** и откатим все изменения, совершенные над ним к первому коммиту. Чтобы сделать это, мы подставим в команду идентификатор нужного коммита, а также путь до файла:
* git checkout 4321 hello.md

## 3. Исправление коммита

Если вы опечатались в комментарии или забыли добавить файл и заметили это сразу после того, как закоммитили изменения, вы легко можете это поправить при помощи **commit —amend.** Эта команда добавит все из последнего коммита в область подготовленных файлов и попытается сделать новый коммит. Это дает вам возможность поправить комментарий или добавить недостающие файлы в область подготовленных файлов.
Для более сложных исправлений, например, не в последнем коммите или если вы успели отправить изменения на сервер, нужно использовать **revert.** Эта команда создаст коммит, отменяющий изменения, совершенные в коммите с заданным идентификатором.
Самый последний коммит может быть доступен по алиасу **HEAD:**

* git revert HEAD

Для остальных будем использовать идентификаторы:

* git revert 1234

При отмене старых коммитов нужно быть готовым к тому, что возникнут конфликты. Такое случается, если файл был изменен еще одним, более новым коммитом. И теперь **git** не может найти строчки, состояние которых нужно откатить, так как они больше не существуют.

## Заключение 1.

Наше краткое руководство по части 1 окончено.
А также, можно подробнее разобрать: 
* **ветвление**
* **разрешение конфликтов при слиянии**

# 2 Часть 

## __Разберем темы:__ 

* ## ветвление
* ## разрешение конфликтов при слиянии
# Ветвление
Во время разработки новой функциональности считается хорошей практикой работать с копией оригинального проекта, которую называют веткой. Ветви имеют свою собственную историю и изолированные друг от друга изменения до тех пор, пока вы не решаете слить изменения вместе. Это происходит по набору причин:

Уже рабочая, стабильная версия кода сохраняется.
Различные новые функции могут разрабатываться параллельно разными программистами.
Разработчики могут работать с собственными ветками без риска, что кодовая база поменяется из-за чужих изменений.
В случае сомнений, различные реализации одной и той же идеи могут быть разработаны в разных ветках и затем сравниваться.

## 1. Создание новой ветки
Основная ветка в каждом репозитории называется master или main. Чтобы создать еще одну ветку, используем команду __branch "name"__

> __git branch Branch_1__

Это создаст новую ветку, пока что точную копию ветки master/msin.

## 2. Переключение между ветками
Сейчас, если мы запустим __branch__, мы увидим две доступные опции:

> __git branch__

> __Branch_1__

> __*master/main__

_**master/main**_ — это активная ветка, она помечена звездочкой. Но мы хотим работать с нашей “новой потрясающей фичей”, так что нам понадобится переключиться на другую ветку. Для этого воспользуемся командой **checkout**, она принимает один параметр — имя ветки, на которую необходимо переключиться.

> __git checkout Branch_1__

В Git __ветка__ — это отдельная линия разработки. **Git checkout** позволяет нам переключаться как между удаленными, так и меду локальными ветками. Это один из способов получить доступ к работе коллеги или соавтора, обеспечивающий более высокую продуктивность совместной работы. Однако тут надо помнить, что пока вы не __закомитили изменения__, вы не сможете переключиться на другую ветку. В такой ситуации нужно либо сделать _коммит_, либо отложить его, при помощи команды _git stash_, добавляющей текущие незакоммиченные изменения в стек изменений и сбрасывающей рабочую копию до HEAD'а репозитория.

# 3. Слияние веток
Наша “потрясающая новая фича” будет еще одним текстовым файлом под названием feature.md. Мы создадим его, добавим и закоммитим:

> __git add Fail.md__

> __git commit -m "New Fail complete."__

Изменения завершены, теперь мы можем переключиться обратно на ветку __master/main__.

> __git checkout master/main__

Теперь, если мы откроем наш проект в файловом менеджере, мы не увидим файла **Fail.md**, потому что мы переключились обратно на ветку _master/main_, в которой такого файла не существует. Чтобы он появился, нужно воспользоваться __merge__ для объединения веток (применения изменений из ветки __Branch_1__ к основной версии проекта).

> __git merge Branch_1__

Теперь ветка master актуальна. Ветка *Branch_1* больше не нужна, и ее можно удалить.

> __git branch -d Branch_1__

Если хотите создать копию удаленного репозитория - используйте __git clone__. Однако если вам нужна только определенная его ветка, а не все хранилище - после _git clone_ выполните следующую команду в соответствующем репозитории:

> __git checkout -b <имя ветки> origin/<имя ветки>__

После этого, новая ветка создается на машине автоматически.

# Как удалять ветки в Git?
Бывают ситуации, когда после слива каких-то изменений из рабочей ветки в исходную версию проекта, ее, по правилам хорошего тона, необходимо удалить, чтобы она более не мешалась в вашем коде. Но как это сделать?
Для локально расположенных веток существует команда:

> **git branch -d local_branch_name**

где флажок *-d* являющийся опцией команды __git branch__ - это сокращенная версия ключевого слова _--delete_, предназначенного для удаления ветки, а **local_branch_name** – название ненужной нам ветки.
Однако тут есть нюанс: удалить текущую ветку, в которую вы, в данный момент просматриваете - нельзя. Если же вы все-таки попытаетесь это сделать, система отругает вас и выдаст ошибку с таким содержанием:

> **Error: Cannot delete branch local_branch_name checked out at название_директории**

Так что при удалении ветвей, обязательно переключитесь на другой __branch__.

# 3 часть: 
# Удаленные репозитории

Сейчас наш коммит является локальным — существует только в директории. git на нашей файловой системе. Несмотря на то, что сам по себе локальный репозиторий полезен, в большинстве случаев мы хотим поделиться нашей работой или доставить код на сервер, где он будет выполняться.

## 1. Что такое удаленный репозиторий

Репозиторий, хранящийся в облаке, на стороннем сервисе, специально созданном для работы с **git** имеет ряд преимуществ. Во-первых - это своего рода резервная копия вашего проекта, предоставляющая возможность безболезненной работы в команде. А еще в таком репозитории можно пользоваться дополнительными возможностями хостинга. К примеру -визуализацией истории или возможностью разрабатывать вашу программу непосредственно в веб-интерфейсе.

**Клонирование**

*Клонирование* - это когда вы копируете удаленный репозиторий к себе на локальный ПК. Это то, с чего обычно начинается любой проект. При этом вы переносите себе все файлы и папки проекта, а также всю его историю с момента его создания. Чтобы склонировать проект, сперва, необходимо узнать где он расположен и скопировать ссылку на него. В нашем руководстве мы будем использовать адрес:
* git clone https: .../awesome-project

При клонировании в текущий каталог, там будет создана папка, в которую поместятся все проектные файлы и скрытая директория .git, с самим репозиторием, или с необходимой информацией о нем. В такой ситуации, для клонируемого репозитория, по умолчанию, будет создана папка с одноименным названием, но его можно залить и в другую директорию, например:

* git clone https: .../awesome-project new-folder

## 2. Подключение к удаленному репозиторию

Чтобы загрузить что-нибудь в удаленный репозиторий, сначала нужно к нему подключиться. Регистрация и установка может занять время, но все подобные сервисы предоставляют хорошую документацию.
Чтобы связать наш локальный репозиторий с репозиторием на GitHub, выполним следующую команду в терминале. Обратите внимание, что нужно обязательно изменить URI репозитория на свой.

* #This is only an example. Replace the URI with your own repository address.

* $ git remote add origin https:// .../awesome-project.git

Проект может иметь несколько удаленных репозиториев одновременно. Чтобы их различать, мы дадим им разные имена. Обычно главный репозиторий называется **origin.**

## 3. Отправка изменений на сервер

Сейчас самое время переслать наш локальный коммит на сервер. Этот процесс происходит каждый раз, когда мы хотим обновить данные в удаленном репозитории.
Команда, предназначенная для этого - **push.** Она принимает два параметра: имя удаленного репозитория (мы назвали наш **origin**) и ветку, в которую необходимо внести изменения (**master** или **main** — это ветка по умолчанию для всех репозиториев).

*  git push origin main

  ...

  *[new branch] main -> main

Эта команда немного похожа на **git fetch**, с той лишь разницей, что при помощи **fetch** мы импортируем коммиты в локальную ветку, а применив **push**, мы экспортируем их из локальной в удаленную. Если вам необходимо настроить удаленную ветку используйте **git remote.** Однако пушить надо осторожно, ведь рассматриваемая команда перезаписывает безвозвратно все изменения. В большинстве случаев, ее используют, чтобы опубликовать выгружаемые локальные изменения в центральный репозиторий. А еще ее применяют для того, чтобы поделиться, внесенными в локальный репозиторий, нововведениями, с коллегами или другими удаленными участниками разработки проекта. Подытожив сказанное, можно назвать **git push** - командой выгрузки, а **git pull** и **git fetch** - командами загрузки или скачивания. После того как вы успешно запушили измененные данные, их необходимо внедрить или интегрировать, при помощи команды слияния **git merge.**
В зависимости от сервиса, который вы используете, вам может потребоваться аутентифицироваться, чтобы изменения отправились. Если все сделано правильно, то когда вы посмотрите в удаленный репозиторий при помощи браузера, вы увидите файл **hello.txt** или **hello.md**

## 4. Запрос изменений с сервера

Если вы сделали изменения в вашем удаленном репозитории, другие пользователи могут скачать изменения при помощи команды **pull.**

* git pull origin main

  
Так как новых коммитов с тех пор, как мы склонировали себе проект, не было, никаких изменений доступных для скачивания нет.

# Заключение2.
## Вот и все! Наше руководство окончено. **Git** довольно сложен, и в нем есть еще много функций и трюков.

